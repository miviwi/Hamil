#pragma once

#include <gx/gx.h>

#include <util/ref.h>
#include <util/format.h>
#include <math/geometry.h>

#include <string>
#include <vector>
#include <unordered_map>
#include <initializer_list>
#include <optional>

namespace gx {

class VertexArray;
class IndexedVertexArray;
class IndexBuffer;

// Base class for Eugene/UniformGen definitions
//   Eugene looks for classes which inherit from it
//   and generates code for Program::getUniformsLocation()
// Limitations:
//   - The derived classes cannot be declared inside of functions,
//     other classes or nested namespaces (a declaration directly
//     inside a namespace is ok though)
struct Uniforms {
  // Symbolic type for declaring a Program's name e.g.:
  //   struct Program {
  //     Name program;
  //     ...
  //   };
  struct Name { };

  using Sampler = int;
};

class Shader {
public:
  enum Type {
    Invalid,
    Vertex   = GL_VERTEX_SHADER,
    Geometry = GL_GEOMETRY_SHADER,
    Fragment = GL_FRAGMENT_SHADER,
  };

  using SourcesList = std::vector<const char *>;

  Shader(Type type, SourcesList sources);
  Shader(Type type, const char *const sources[], size_t count);
  Shader(const Shader&) = delete;
  ~Shader();

  void label(const char *label);
  void label(const std::string& label_);

private:
  friend class Program;

  GLuint m;
};

struct UniformDescriptor {
  int offset;

  int array_size;
  int array_stride;
};

class Program : public Ref {
public:
  using DescriptorMap = std::unordered_map<std::string, UniformDescriptor>;

  Program(const Shader& vertex, const Shader& fragment);
  Program(const Shader& vertex, const Shader& geometry, const Shader& fragment);
  Program(const Program& other) = default;
  Program(Program&& other);
  ~Program();

  Program& operator=(Program&& other);

  // Uses sources autogenerated from classes that derive from 'Uniforms'
  //   each member becomes a uniform variable location
  template <typename T>
  void getUniformsLocations(T& klass)
  {
    getUniforms(T::offsets.data(), T::offsets.size(), klass.locations);
  }
  GLint getUniformLocation(const char *name);

  unsigned getUniformBlockIndex(const char *name);
  Program& uniformBlockBinding(unsigned block, unsigned index);
  Program& uniformBlockBinding(const char *name, unsigned index);

  const DescriptorMap& uniformBlockDescriptors(unsigned block);
  const DescriptorMap& uniformBlockDescriptors(const char *name);

  int getOutputLocation(const char *name);

  Program& use();

  Program& uniformInt(int location, int i);
  Program& uniformSampler(int location, int i);
  Program& uniformFloat(int location, float f);
  Program& uniformVector3(int location, size_t size, const vec3 *v);
  Program& uniformVector3(int location, vec3 v);
  Program& uniformVector4(int location, size_t size, const vec4 *v);
  Program& uniformVector4(int location, vec4 v);
  Program& uniformMatrix4x4(int location, const mat4& mtx, bool transpose = true);
  Program& uniformMatrix3x3(int location, const mat3& mtx, bool transpose = true);
  Program& uniformMatrix3x3(int location, const mat4& mtx, bool transpose = true);
  Program& uniformBool(int location, bool v);

  void draw(Primitive p, const VertexArray& vtx, size_t offset, size_t num);
  void draw(Primitive p, const VertexArray& vtx, size_t num);
  void draw(Primitive p, const IndexedVertexArray& vtx, size_t offset, size_t num);
  void draw(Primitive p, const IndexedVertexArray& vtx, size_t num);

  void drawBaseVertex(Primitive p,
    const IndexedVertexArray& vtx, size_t base, size_t offset, size_t num);

  void label(const char *lbl);

  static void unbind();

private:
  void link();
  void getUniforms(const std::pair<std::string, unsigned> *offsets, size_t sz, int locations[]);
  void getUniformBlockDescriptors();

  GLuint m;

  using DescriptorMapVector = std::vector<DescriptorMap>;

  static const DescriptorMap m_null_descs;
  // Lazy initialized in uniformBlockDescriptors()
  std::optional<DescriptorMapVector> m_ubo_descs = std::nullopt;
};

// 'label' is optional (can be == nullptr), when given the
//   returned Program will have it set as it's label,
//   while the Shaders it's composed of will have the labels
//      label+"VS"   and   label+"FS"
//   respectively
template <typename T>
static Program make_program(const char *label,
  Shader::SourcesList vs_src, Shader::SourcesList fs_src,
  T& uniforms)
{
  Shader vs(gx::Shader::Vertex,   vs_src);
  Shader fs(gx::Shader::Fragment, fs_src);

  if(label) {
    vs.label(util::fmt("%sVS", label));
    fs.label(util::fmt("%sFS", label));
  }

  Program prog(vs, fs);

  if(label) prog.label(label);
  prog.getUniformsLocations(uniforms);

  return prog;
}

// 'label' is optional (can be == nullptr)
//    - See note above:
//          make_program(label, vs, fs, uniforms)
//      for info on how Shader labels are created
//      from 'label'
template <typename T>
static Program make_program(const char *label,
  Shader::SourcesList vs_src, Shader::SourcesList gs_src, Shader::SourcesList fs_src,
  T& uniforms)
{
  Shader vs(gx::Shader::Vertex,   vs_src);
  Shader gs(gx::Shader::Geometry, gs_src);
  Shader fs(gx::Shader::Fragment, fs_src);

  if(label) {
    vs.label(util::fmt("%sVS", label));
    gs.label(util::fmt("%sGS", label));
    fs.label(util::fmt("%sFS", label));
  }

  Program prog(vs, gs, fs);

  if(label) prog.label(label);
  prog.getUniformsLocations(uniforms);

  return prog;
}

}
